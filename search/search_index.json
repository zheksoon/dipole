{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dipole is tiny (just about 2K min gz) reactive state management library that could be used standalone or with React/Preact. It's heavily inspired by MobX and was initially thought as a pedagogical re-implementation of its core features, and had grown later to a complete library. At this moment dipole can be seen as MobX minus \"magic\". dipole features : Clean and minimalistic object-oriented implementation of observable/functional reactive paradigm in about 500 lines of code Opaque data structures - you can easily examine dipole internals in debugger, no class fields is mangled Performance optimizations - even with a huge amount of observable/computed values dipole runs as efficiently as possible Good test suit - 100% test coverage for complex use cases Installation npm install --save dipole Introduction Check out the introduction page Examples Check out the Examples page Author Eugene Daragan License MIT","title":"Home"},{"location":"#installation","text":"npm install --save dipole","title":"Installation"},{"location":"#introduction","text":"Check out the introduction page","title":"Introduction"},{"location":"#examples","text":"Check out the Examples page","title":"Examples"},{"location":"#author","text":"Eugene Daragan","title":"Author"},{"location":"#license","text":"MIT","title":"License"},{"location":"api/","text":"API reference Observable constructor interface IObservableOptions<T> { checkValue?: (prevValue: T, nextValue: T) => boolean; } new Observable<T>(value: T, options?: IObservableOptions<T>): Observable<T> observable<T>(value: T, options?: IObservableOptions<T>): Observable<T> Creates an Observable instance containing the value . options object may optionally contain checkValue function, which will be invoked on every set() call and compare current and new observable values. If the checkValue returns true (means the values are equal), change signal is not propogated to its subscribers. .get() Observable.prototype.get() Get the value from Observable instance and track the usage of the observable into currently executed Computed or Reaction .set(value) Observable.prototype.set(value) Sets a new value of Observable , notifying dependent Computed / Reaction about the change. If the observable instance was created with checkValue function, performs the check first and does the subscribers notification only if checkValue returned false . .notify() Observable.prototype.notify() Notify dependent Computed / Reaction about a change in underlying Observable 's value. Useful after changing mutable objects like Arrays, Maps or any other objects. checkValue option doesn't change the behaviour. Computed constructor interface IComputedOptions<T> { checkValue?: (prevValue: T, nextValue: T) => boolean; keepAlive?: boolean; } new Computed<T>(computer: () => T, options?: IComputedOptions<T>) computed<T>(computer: () => T, options?: IComputedOptions<T>) Create a Computed instance with computer function used for computed value calculations. computer must be a pure function and not change/notify any observable - only .get() calls to other Observable / Computed values are prohibited. options object may optionally contain checkValue function, which enables complex logic that stops dependant reactions or computed values from running if the value of the computed hasn't changed. keepAlive option prevents the computed value from being destroyed when is looses all subscribers or after being accessed outside of reactive context. .get() Computed.prototype.get() Get result of computer function invocation. The result is computed at the moment of invocation, if it's the first time the method is called or some of computed dependencies are changed. Otherwise, cached value is returned. Also it tracks the usage of the computed into underlying Computed or Reaction Reaction constructor new Reaction(reactor [, context [, manager, [, options]]]) reaction(reactor [, context [, manager, [, options]]]) Creates a Reaction instance with reactor function in its core, with optional context and manager arguments. context is this argument for reactor param, defaults to undefined . manager is a function that should somehow schedule/manage invocation of .run() method of the object on reaction's dependency change. See dipole-react bindings for example of manager usage. The options argument has following definition: interface IReactionOptions { autocommitSubscriptions?: boolean; } Options description: autocommitSubscriptions?: boolean (default value - true ): when false , forces Reaction instance not to subscribe to observable and computed values automatically, only after manually calling commitSubscriptions method. This option was added to support SSR, Concurrent and Strict Modes in dipole-react connector, when rendered component can be thrown away. Without the option it would introduce a memory leak. Please see dipole-react source code for more details. .run(...args) Runs reaction's reactor function with this set to context and passes all method's arguments to it. Reaction body runs in implicit transaction, so there is no need to use transactions inside of it. .destroy() Destroys reaction, so it doesn't react to any changes anymore before next manual invocation of .run() method. .commitSubscriptions() The method has effect only in case autocommitSubscriptions option was set to false . It make the reaction instance subscribe to all its dependencies that were collected during the last .run() call. .setOptions(options) The method allows to set reaction options on the fly. Currently only autocommitSubscriptions is supported. It's better not to call the method inside of .run() , so reaction's subscriptions will be consistent. Actions and transactions action action((...args) => { ...action body... }) Returns a function wrapped in untracked transaction. Calls to the resulting function will pass all arguments and this to action body. Since action body is untracked, .get() calls or getters to any observables/computed values won't introduce new dependencies when called inside action body (but it's not true for transaction). transaction (tx) tx(() => { ...transaction body... }) Execute transaction body function in transaction block. The body function is invoked without any arguments or this . untracked transaction (utx) utx(() => { ...transaction body with result... }) Execute transaction body in untracked transaction and return execution result. Because transaction is untracked, .get() calls or getters to any observables/computed values won't introduce new dependencies when called inside of it. Utilities makeObservable(object) makeObservable(object) Iterates through own enumerable properties and replaces them with getters/setters for each instanse of Observable/Computed classes. Only properties are processed, so if there are already some getters on the object, they won't be invoked. Mutates the object and returns it as result. fromGetter(thunk) fromGetter(() => { ...some getter call to observable/computed... }) Returns an observable/computed object hidden under some getter called in the body function. Returns undefined if the function didn't call any getters/ .get() methods. If there is more than one getter call in the body function, only result for the latest one returned. notify(thunk) notify(() => { ...some getter calls on observables... }) Calls .notify() method on all observables, which getters were executed in body function. configure dipole has global configure function that allows to tune some internal behaviour. interface IConfig { reactionScheduler?: (runner: () => void) => void; subscribersCheckInterval?: number; } export function configure(config: IConfig): void; reactionScheduler reactionScheduler option allows to customize the way how reaction queue will be runned. The option must be a function that takes one argument ( runner ), and, when called, should somehow run the runner function. Default implementation is equivalent to the following: configure({ reactionScheduler: (runner) => runner(), }) e.g. runs the runner immediately. For some practical use cases (especially when asyncronous operations are used) microtask runner could be useful: configure({ reactionScheduler: (runner) => Promise.resolve().then(runner), }) This will allow to skip wrapping observable state changes inside async flow in utx functions, allowing cleaner code like this: class UserModel { fetchUsers = action(async () => { this.isLoading = true; try { this.users = await fetch(...).then((res) => res.json()); } catch (err) { this.error = err; } finally { this.isLoading = false; } }) } subscribersCheckInterval subscribersCheckInterval option is interval in milliseconds for how often computed values that lost all their subscriptions (or never gained them) will be invalidated. Default value is 1000 .","title":"API reference"},{"location":"api/#api-reference","text":"","title":"API reference"},{"location":"api/#observable","text":"","title":"Observable"},{"location":"api/#constructor","text":"interface IObservableOptions<T> { checkValue?: (prevValue: T, nextValue: T) => boolean; } new Observable<T>(value: T, options?: IObservableOptions<T>): Observable<T> observable<T>(value: T, options?: IObservableOptions<T>): Observable<T> Creates an Observable instance containing the value . options object may optionally contain checkValue function, which will be invoked on every set() call and compare current and new observable values. If the checkValue returns true (means the values are equal), change signal is not propogated to its subscribers.","title":"constructor"},{"location":"api/#get","text":"Observable.prototype.get() Get the value from Observable instance and track the usage of the observable into currently executed Computed or Reaction","title":".get()"},{"location":"api/#setvalue","text":"Observable.prototype.set(value) Sets a new value of Observable , notifying dependent Computed / Reaction about the change. If the observable instance was created with checkValue function, performs the check first and does the subscribers notification only if checkValue returned false .","title":".set(value)"},{"location":"api/#notify","text":"Observable.prototype.notify() Notify dependent Computed / Reaction about a change in underlying Observable 's value. Useful after changing mutable objects like Arrays, Maps or any other objects. checkValue option doesn't change the behaviour.","title":".notify()"},{"location":"api/#computed","text":"","title":"Computed"},{"location":"api/#constructor_1","text":"interface IComputedOptions<T> { checkValue?: (prevValue: T, nextValue: T) => boolean; keepAlive?: boolean; } new Computed<T>(computer: () => T, options?: IComputedOptions<T>) computed<T>(computer: () => T, options?: IComputedOptions<T>) Create a Computed instance with computer function used for computed value calculations. computer must be a pure function and not change/notify any observable - only .get() calls to other Observable / Computed values are prohibited. options object may optionally contain checkValue function, which enables complex logic that stops dependant reactions or computed values from running if the value of the computed hasn't changed. keepAlive option prevents the computed value from being destroyed when is looses all subscribers or after being accessed outside of reactive context.","title":"constructor"},{"location":"api/#get_1","text":"Computed.prototype.get() Get result of computer function invocation. The result is computed at the moment of invocation, if it's the first time the method is called or some of computed dependencies are changed. Otherwise, cached value is returned. Also it tracks the usage of the computed into underlying Computed or Reaction","title":".get()"},{"location":"api/#reaction","text":"","title":"Reaction"},{"location":"api/#constructor_2","text":"new Reaction(reactor [, context [, manager, [, options]]]) reaction(reactor [, context [, manager, [, options]]]) Creates a Reaction instance with reactor function in its core, with optional context and manager arguments. context is this argument for reactor param, defaults to undefined . manager is a function that should somehow schedule/manage invocation of .run() method of the object on reaction's dependency change. See dipole-react bindings for example of manager usage. The options argument has following definition: interface IReactionOptions { autocommitSubscriptions?: boolean; } Options description: autocommitSubscriptions?: boolean (default value - true ): when false , forces Reaction instance not to subscribe to observable and computed values automatically, only after manually calling commitSubscriptions method. This option was added to support SSR, Concurrent and Strict Modes in dipole-react connector, when rendered component can be thrown away. Without the option it would introduce a memory leak. Please see dipole-react source code for more details.","title":"constructor"},{"location":"api/#runargs","text":"Runs reaction's reactor function with this set to context and passes all method's arguments to it. Reaction body runs in implicit transaction, so there is no need to use transactions inside of it.","title":".run(...args)"},{"location":"api/#destroy","text":"Destroys reaction, so it doesn't react to any changes anymore before next manual invocation of .run() method.","title":".destroy()"},{"location":"api/#commitsubscriptions","text":"The method has effect only in case autocommitSubscriptions option was set to false . It make the reaction instance subscribe to all its dependencies that were collected during the last .run() call.","title":".commitSubscriptions()"},{"location":"api/#setoptionsoptions","text":"The method allows to set reaction options on the fly. Currently only autocommitSubscriptions is supported. It's better not to call the method inside of .run() , so reaction's subscriptions will be consistent.","title":".setOptions(options)"},{"location":"api/#actions-and-transactions","text":"","title":"Actions and transactions"},{"location":"api/#action","text":"action((...args) => { ...action body... }) Returns a function wrapped in untracked transaction. Calls to the resulting function will pass all arguments and this to action body. Since action body is untracked, .get() calls or getters to any observables/computed values won't introduce new dependencies when called inside action body (but it's not true for transaction).","title":"action"},{"location":"api/#transaction-tx","text":"tx(() => { ...transaction body... }) Execute transaction body function in transaction block. The body function is invoked without any arguments or this .","title":"transaction (tx)"},{"location":"api/#untracked-transaction-utx","text":"utx(() => { ...transaction body with result... }) Execute transaction body in untracked transaction and return execution result. Because transaction is untracked, .get() calls or getters to any observables/computed values won't introduce new dependencies when called inside of it.","title":"untracked transaction (utx)"},{"location":"api/#utilities","text":"","title":"Utilities"},{"location":"api/#makeobservableobject","text":"makeObservable(object) Iterates through own enumerable properties and replaces them with getters/setters for each instanse of Observable/Computed classes. Only properties are processed, so if there are already some getters on the object, they won't be invoked. Mutates the object and returns it as result.","title":"makeObservable(object)"},{"location":"api/#fromgetterthunk","text":"fromGetter(() => { ...some getter call to observable/computed... }) Returns an observable/computed object hidden under some getter called in the body function. Returns undefined if the function didn't call any getters/ .get() methods. If there is more than one getter call in the body function, only result for the latest one returned.","title":"fromGetter(thunk)"},{"location":"api/#notifythunk","text":"notify(() => { ...some getter calls on observables... }) Calls .notify() method on all observables, which getters were executed in body function.","title":"notify(thunk)"},{"location":"api/#configure","text":"dipole has global configure function that allows to tune some internal behaviour. interface IConfig { reactionScheduler?: (runner: () => void) => void; subscribersCheckInterval?: number; } export function configure(config: IConfig): void;","title":"configure"},{"location":"api/#reactionscheduler","text":"reactionScheduler option allows to customize the way how reaction queue will be runned. The option must be a function that takes one argument ( runner ), and, when called, should somehow run the runner function. Default implementation is equivalent to the following: configure({ reactionScheduler: (runner) => runner(), }) e.g. runs the runner immediately. For some practical use cases (especially when asyncronous operations are used) microtask runner could be useful: configure({ reactionScheduler: (runner) => Promise.resolve().then(runner), }) This will allow to skip wrapping observable state changes inside async flow in utx functions, allowing cleaner code like this: class UserModel { fetchUsers = action(async () => { this.isLoading = true; try { this.users = await fetch(...).then((res) => res.json()); } catch (err) { this.error = err; } finally { this.isLoading = false; } }) }","title":"reactionScheduler"},{"location":"api/#subscriberscheckinterval","text":"subscribersCheckInterval option is interval in milliseconds for how often computed values that lost all their subscriptions (or never gained them) will be invalidated. Default value is 1000 .","title":"subscribersCheckInterval"},{"location":"examples/","text":"Examples using React bindings Example 0: Counter. Basics of observables and actions Open in Codesandbox import { action, observable, makeObservable } from \"dipole\"; import { observer } from \"dipole-react\"; let counterId = 0; class CounterModel { // not observable field id = counterId++; // observable field count = observable.prop(0); constructor() { // creates getters and setters for observable fields for transparency makeObservable(this); } // actions are atomic changes on observables, see introduction below inc = action(() => (this.count += 1)); dec = action(() => (this.count -= 1)); reset = action(() => (this.count = 0)); } // React component wrapped into `observer` re-renders on observable changes const Counter = observer(({ model, onRemove }) => { return ( <div> Counter is: {model.count} <button onClick={model.inc}>+</button> <button onClick={model.dec}>-</button> <button onClick={model.reset}>Reset</button> {onRemove && <button onClick={() => onRemove(model.id)}>Remove</button>} </div> ); }); const counterModel = new CounterModel(); ReactDOM.render(<Counter model={counterModel} />, document.getElementById(\"root\")); Example 1: Counter list. Model composition and computed data Using the counter example above, let's compose multiple Counter models into a more complex app. Open in Codesandbox import { computed } from \"dipole\"; class CounterListModel { counters = observable.prop([]); // computeds are fields with data derived from other computeds/observables countersTotal = computed.prop(() => { return this.counters.length; }); countersSum = computed.prop(() => { return this.counters.reduce((acc, counter) => acc + counter.count, 0); }); constructor() { makeObservable(this); } addCounter = action(() => { const counter = new CounterModel(); this.counters.push(counter); // as observables are dumb containers for data, // we need to let them know about changes in underlying data structures this.counters = this.counters; // or notify(() => this.counters) }); removeCounter = action((id) => { // no need for notify() because we are doing an assignment here this.counters = this.counters.filter((counter) => counter.id !== id); }); // action can aggregate multiple other actions and still be atomic resetAll = action(() => { this.counters.forEach((counter) => counter.reset()); }); } const CounterList = observer(({ model }) => { return ( <div> <p>Counters total: {model.countersTotal}</p> <p>Counters sum: {model.countersSum}</p> {model.counters.map((counter) => ( <Counter key={counter.id} model={counter} onRemove={model.removeCounter} /> ))} <button onClick={model.addCounter}>Add counter</button> <button onClick={model.resetAll}>Reset all</button> </div> ); }); const counterListModel = new CounterListModel(); ReactDOM.render(<CounterList model={counterListModel} />, document.getElementById(\"root\")); Example 2: TodoMVC. The classics of. Repository Open in Codesandbox","title":"Examples"},{"location":"examples/#examples-using-react-bindings","text":"","title":"Examples using React bindings"},{"location":"examples/#example-0-counter-basics-of-observables-and-actions","text":"Open in Codesandbox import { action, observable, makeObservable } from \"dipole\"; import { observer } from \"dipole-react\"; let counterId = 0; class CounterModel { // not observable field id = counterId++; // observable field count = observable.prop(0); constructor() { // creates getters and setters for observable fields for transparency makeObservable(this); } // actions are atomic changes on observables, see introduction below inc = action(() => (this.count += 1)); dec = action(() => (this.count -= 1)); reset = action(() => (this.count = 0)); } // React component wrapped into `observer` re-renders on observable changes const Counter = observer(({ model, onRemove }) => { return ( <div> Counter is: {model.count} <button onClick={model.inc}>+</button> <button onClick={model.dec}>-</button> <button onClick={model.reset}>Reset</button> {onRemove && <button onClick={() => onRemove(model.id)}>Remove</button>} </div> ); }); const counterModel = new CounterModel(); ReactDOM.render(<Counter model={counterModel} />, document.getElementById(\"root\"));","title":"Example 0: Counter. Basics of observables and actions"},{"location":"examples/#example-1-counter-list-model-composition-and-computed-data","text":"Using the counter example above, let's compose multiple Counter models into a more complex app. Open in Codesandbox import { computed } from \"dipole\"; class CounterListModel { counters = observable.prop([]); // computeds are fields with data derived from other computeds/observables countersTotal = computed.prop(() => { return this.counters.length; }); countersSum = computed.prop(() => { return this.counters.reduce((acc, counter) => acc + counter.count, 0); }); constructor() { makeObservable(this); } addCounter = action(() => { const counter = new CounterModel(); this.counters.push(counter); // as observables are dumb containers for data, // we need to let them know about changes in underlying data structures this.counters = this.counters; // or notify(() => this.counters) }); removeCounter = action((id) => { // no need for notify() because we are doing an assignment here this.counters = this.counters.filter((counter) => counter.id !== id); }); // action can aggregate multiple other actions and still be atomic resetAll = action(() => { this.counters.forEach((counter) => counter.reset()); }); } const CounterList = observer(({ model }) => { return ( <div> <p>Counters total: {model.countersTotal}</p> <p>Counters sum: {model.countersSum}</p> {model.counters.map((counter) => ( <Counter key={counter.id} model={counter} onRemove={model.removeCounter} /> ))} <button onClick={model.addCounter}>Add counter</button> <button onClick={model.resetAll}>Reset all</button> </div> ); }); const counterListModel = new CounterListModel(); ReactDOM.render(<CounterList model={counterListModel} />, document.getElementById(\"root\"));","title":"Example 1: Counter list. Model composition and computed data"},{"location":"examples/#example-2-todomvc-the-classics-of","text":"Repository Open in Codesandbox","title":"Example 2: TodoMVC. The classics of."},{"location":"introduction/","text":"Introduction into core features Dipole core consists three main classes: Observable , Computed and Reaction . All the classes can be constructed via non-capitalized factory functions observable , computed and reaction correspondingly without new keyword. Observable Observables are containers that contain some value and allow some other dependent objects to get notified when the value changes. import { observable } from 'dipole' const counter = observable(0) counter.get() // returns 0 counter.set(1) // sets observable value to 1 For sure, it might be not convinient to call .get() or .set() on every observable access, so there are some helpers to make the the process easy and transparent. Computed Computed values are values that are derived from other observables and computeds with some pure function. The function should not contain any side-effects other than returning a value and depend only on observable/computed values. The result of computed is cached until any of its dependencies are changed. import { observable, computed } from 'dipole' const counter = observable(1) const double = computed(() => { console.log('Computing double value...') return counter.get() * 2 }) double.get() // prints 'Computing double value...' and returns 2 double.get() // doesn't print and returns 2 - the result is cached! counter.set(2) // update computed dependency double.get() // prints 'Computing double value...' and returns 4 // another way to invalidate an observable is to call `.notify()` // this is useful when observable contains a complex object like Array or Map counter.notify() double.get() // prints 'Computing double value...' and returns 4 again Of course computed values can contain any kind of conditions/loops that dynamically reference to different observables, this will be correctly handled by dipole: const cond = observable(true) const a = observable('a') const b = observable('b') const result = computed(() => { console.log('Computing result...') return cond.get() ? a.get() : b.get() }) result.get() // prints 'Computing result' and returns 'a' // now `result` depends on `cond` and `a` values cond.set(false) result.get() // prints 'Computing result' and returns 'b' // now `result` depends on `cond` and `b` values a.set('aa') // `result` doesn't depend on `a`, nothing will happen result.get() // nothing changed for `result`, just returns 'b' again b.set('bb') // change `result` dependency result.get() // prints 'Computing result' and returns 'bb' There are some intuitive limitations for computed values: 1) They can't recursively refer to itself: const recur = computed(() => recur.get() + 1) recur.get() // throws 'Trying to get computed value while in computing state' 2) They must not change any observable or trigger any side-effects: const badBoy = computed(() => counter.set(0)) badBoy.get() // throws `Can't change observable value inside of computed` Reaction and transaction Reactions are automatic actions that are triggered on dependent observable/computed changes const a = observable(1) const b = observable(2) const sum = computed(() => a.get() + b.get()) const r = reaction(() => { console.log(`Sum of ${a.get()} and ${b.get()} is ${sum.get()}`) }) r.run() // first run should be triggered manually // prints 'Sum of 1 and 2 is 3' a.set(3) // prints 'Sum of 3 and 2 is 5' b.set(4) // prints 'Sum of 3 and 4 is 7' Transaction Last lines show that reaction reacts to each change in its dependencies, synchronously. But what if we want to batch changes and run reaction only once after both a and b changes? Here's the answer: transaction : // `tx` stands for `transaction` import { tx } from 'dipole' tx(() => { a.set(2) // doesn't react b.set(3) // doesn't react too }) // prints 'Sum 2 and 3 is 5' right after the transaction end Action and untracked transaction Actions are functions wrapped in transaction. But there is also one significant difference with plain transactions: actions are untracked . This means that any access to any observable or computed fields performed in action won't be tracked by calling function/reaction. This makes actions building pieces of your application - they could be safely called from any place with predictable consequences. Actions do really play well with observable utilities , making writing complex mutations simple. import { observable, action, makeObservable } from 'dipole' class SumModel { constructor(a, b) { this.a = observable.prop(a) this.b = observable.prop(b) makeObservable(this) } addBoth = action((amount) => { this.a += amount this.b += amount }) } const model = new SumModel(1, 2); model.addBoth(3); Sometimes inplace untracked transactions are usefull too, so there is utx function for this ( utx stands for Untracked TX): class UserModel { isLoading = observable.prop(false); user = observanle.prop(null); error = observable.prop(null); constructor() { makeObservable(this); } // async functions can't be wrapped in `action`, so using `utx` inplace for observable changes async fetchUser() { utx(() => this.isLoading = true); try { const response = await userService.getData(); utx(() => { this.user = response.user; this.isLoading = false; }); } catch (err) { utx(() => { this.error = err; this.isLoading = false; }) } } } utx function also returns the result of its body execution, so it could be used for peeking at some observables/computed values without getting them tracked by underlying reaction/computed: const person = observable('Alice') const government = reaction(() => { const who = utx(() => person.get()); console.log(`${who} is caught!`); }) government.run(); // Alice is caught! but... person.set('Anonymous') // you get it! :) Reactions can be destroyed, so they will not run after that: r.destroy() a.set(4) // doesn't react to the change anymore Nested reactions Since dipole version 2.2.0 reactions that get created while another reaction is executed become children of the parent reaction. Child reactions get automatically destroyed when parent is destroyed or run. Why is this needed? This behaviour enables building hierarchical constructs, where one reaction (say, router) creates another reaction (say, view or page), and changes that trigger router reaction automatically destroy view reaction, so all related resources could be freed. For more context, see this issue . In case you want intentially create a reaction without parent, just do it inside untracked transaction: const free = utx(() => reaction(() => { ...reaction body... })); Advanced reaction usage Advanced reaction usage with reaction context and manager argument: const delayed = reaction( () => console.log(counter.get()), // reaction body null, // reaction context (`this` for reaction body) () => setTimeout(() => delayed.run(), 1000) // reaction manager, should manage to run `.run()` method somehow ) delayed.run() // prints '3' counter.set(4) // prints '4' after 1 second Limitations Please avoid changing reaction's dependencies inside reaction body - this will cause reaction running in an infinite loop: const forever = reaction(() => counter.set(counter.get() + 1)) forever.run() // never ends Reaction utilities There are two utility functions that can help is some cases: when() accepts a condition function and body, so body gets executed in untracked transaction each time condition is true: const cond = observable(false); const r = when( () => cond.get(), () => { console.log(\"Condition is true\") } ); cond.set(true); // prints \"Condition is true\" cond.set(false); // doesn't print once() works the same as when() except the fact it runs only once when condition is set to true : const cond = observable(false); const r = once( () => cond.get(), () => { console.log(\"Condition is true\") } ); cond.set(true); // prints \"Condition is true\" cond.set(false); // doesn't print cond.set(true); // doesn't print too In all cases, when() and once() will run body if condition is initially set to true . Returned object is Reaction instance, so it could be destroyed or run again as usual reaction. Observable utilities Using makeObservable helper it's easy to convert observable properties on some object into convenient getters and setters: const counter = makeObservable({ count: observable(0) }) counter.count // return 0 counter.count = 5 // sets observable to 5 Or the same with classes: class Counter { count = observable(0) constructor() { makeObservable(this) } } const counter = new Counter() Only object's own properties are converted . (You may also have noticed that code from Examples section uses observable.prop instead of observable for defining fields - in fact, it's exactly the same function, the only difference is its Typescript definition : type of observable.prop(T) is T , while type of observable(T) is Observable<T> ) There are also few helper functions designed to work with makeObservable : fromGetter and notify . Extra: value-checked observables and computeds By default, observables and computeds never touch the values they store, so they can't know if the assigned or computed value has changed. It's convinient for the most cases, but sometimes might lead to unnecessarily reactions or expensive computations you might want to eliminate. Observables and computeds receive an second options parameter, which can contain checkValue function, which receives previous and new values and returns a boolean equality result. If the result is true , no further recomputations of dependant computeds or reactions is done. Here's an example: // simple comparison function const checkValue = (prev, next) => prev === next; // pass the checkValue function to observable const counter = observable(1, { checkValue }); // pass the checkValue function to computed const absolute = computed( () => { console.log('computing absolute'); return Math.abs(counter.get()); }, { checkValue }, ); // regular computed without value check const doubleAbsolute = computed(() => { console.log('computing double') return absolute.get() * 2; }); const printer = reaction(() => { console.log('result is', doubleAbsolute.get()); }); // first run, prints 'computing absolute' and 'computing double' printer.run(); // checkValue is called for observable, no computeds are recalculated, reaction doesn't run counter.set(1); // prints 'computing absolute' and calls checkValue for computed, // doubleAbsolute computed is not recalculated and reaction doesn't run counter.set(-1); While the feature seems like a \"silver bullet\" for reducing amount of computation in your application, it comes with a price. Because dipole is guaratied to be glitch-free and consistent at every moment of time, there is some quite complicated logic behind the checkValue feature. Internally, dipole does a \"virtual\" run of every reaction potentially touched by the value-checked computeds change (called internally a \"state actualization\"), which implements some kind of topological sort of to-be-recomputed values, so the process might be not as lightweight as you could imagine. Given the fact, it's better to place value-checked computeds as close to reactions or consumers as possible, or at least benchmark cases with and without checkValue option.","title":"Introduction"},{"location":"introduction/#introduction-into-core-features","text":"Dipole core consists three main classes: Observable , Computed and Reaction . All the classes can be constructed via non-capitalized factory functions observable , computed and reaction correspondingly without new keyword.","title":"Introduction into core features"},{"location":"introduction/#observable","text":"Observables are containers that contain some value and allow some other dependent objects to get notified when the value changes. import { observable } from 'dipole' const counter = observable(0) counter.get() // returns 0 counter.set(1) // sets observable value to 1 For sure, it might be not convinient to call .get() or .set() on every observable access, so there are some helpers to make the the process easy and transparent.","title":"Observable"},{"location":"introduction/#computed","text":"Computed values are values that are derived from other observables and computeds with some pure function. The function should not contain any side-effects other than returning a value and depend only on observable/computed values. The result of computed is cached until any of its dependencies are changed. import { observable, computed } from 'dipole' const counter = observable(1) const double = computed(() => { console.log('Computing double value...') return counter.get() * 2 }) double.get() // prints 'Computing double value...' and returns 2 double.get() // doesn't print and returns 2 - the result is cached! counter.set(2) // update computed dependency double.get() // prints 'Computing double value...' and returns 4 // another way to invalidate an observable is to call `.notify()` // this is useful when observable contains a complex object like Array or Map counter.notify() double.get() // prints 'Computing double value...' and returns 4 again Of course computed values can contain any kind of conditions/loops that dynamically reference to different observables, this will be correctly handled by dipole: const cond = observable(true) const a = observable('a') const b = observable('b') const result = computed(() => { console.log('Computing result...') return cond.get() ? a.get() : b.get() }) result.get() // prints 'Computing result' and returns 'a' // now `result` depends on `cond` and `a` values cond.set(false) result.get() // prints 'Computing result' and returns 'b' // now `result` depends on `cond` and `b` values a.set('aa') // `result` doesn't depend on `a`, nothing will happen result.get() // nothing changed for `result`, just returns 'b' again b.set('bb') // change `result` dependency result.get() // prints 'Computing result' and returns 'bb' There are some intuitive limitations for computed values: 1) They can't recursively refer to itself: const recur = computed(() => recur.get() + 1) recur.get() // throws 'Trying to get computed value while in computing state' 2) They must not change any observable or trigger any side-effects: const badBoy = computed(() => counter.set(0)) badBoy.get() // throws `Can't change observable value inside of computed`","title":"Computed"},{"location":"introduction/#reaction-and-transaction","text":"Reactions are automatic actions that are triggered on dependent observable/computed changes const a = observable(1) const b = observable(2) const sum = computed(() => a.get() + b.get()) const r = reaction(() => { console.log(`Sum of ${a.get()} and ${b.get()} is ${sum.get()}`) }) r.run() // first run should be triggered manually // prints 'Sum of 1 and 2 is 3' a.set(3) // prints 'Sum of 3 and 2 is 5' b.set(4) // prints 'Sum of 3 and 4 is 7'","title":"Reaction and transaction"},{"location":"introduction/#transaction","text":"Last lines show that reaction reacts to each change in its dependencies, synchronously. But what if we want to batch changes and run reaction only once after both a and b changes? Here's the answer: transaction : // `tx` stands for `transaction` import { tx } from 'dipole' tx(() => { a.set(2) // doesn't react b.set(3) // doesn't react too }) // prints 'Sum 2 and 3 is 5' right after the transaction end","title":"Transaction"},{"location":"introduction/#action-and-untracked-transaction","text":"Actions are functions wrapped in transaction. But there is also one significant difference with plain transactions: actions are untracked . This means that any access to any observable or computed fields performed in action won't be tracked by calling function/reaction. This makes actions building pieces of your application - they could be safely called from any place with predictable consequences. Actions do really play well with observable utilities , making writing complex mutations simple. import { observable, action, makeObservable } from 'dipole' class SumModel { constructor(a, b) { this.a = observable.prop(a) this.b = observable.prop(b) makeObservable(this) } addBoth = action((amount) => { this.a += amount this.b += amount }) } const model = new SumModel(1, 2); model.addBoth(3); Sometimes inplace untracked transactions are usefull too, so there is utx function for this ( utx stands for Untracked TX): class UserModel { isLoading = observable.prop(false); user = observanle.prop(null); error = observable.prop(null); constructor() { makeObservable(this); } // async functions can't be wrapped in `action`, so using `utx` inplace for observable changes async fetchUser() { utx(() => this.isLoading = true); try { const response = await userService.getData(); utx(() => { this.user = response.user; this.isLoading = false; }); } catch (err) { utx(() => { this.error = err; this.isLoading = false; }) } } } utx function also returns the result of its body execution, so it could be used for peeking at some observables/computed values without getting them tracked by underlying reaction/computed: const person = observable('Alice') const government = reaction(() => { const who = utx(() => person.get()); console.log(`${who} is caught!`); }) government.run(); // Alice is caught! but... person.set('Anonymous') // you get it! :) Reactions can be destroyed, so they will not run after that: r.destroy() a.set(4) // doesn't react to the change anymore","title":"Action and untracked transaction"},{"location":"introduction/#nested-reactions","text":"Since dipole version 2.2.0 reactions that get created while another reaction is executed become children of the parent reaction. Child reactions get automatically destroyed when parent is destroyed or run. Why is this needed? This behaviour enables building hierarchical constructs, where one reaction (say, router) creates another reaction (say, view or page), and changes that trigger router reaction automatically destroy view reaction, so all related resources could be freed. For more context, see this issue . In case you want intentially create a reaction without parent, just do it inside untracked transaction: const free = utx(() => reaction(() => { ...reaction body... }));","title":"Nested reactions"},{"location":"introduction/#advanced-reaction-usage","text":"Advanced reaction usage with reaction context and manager argument: const delayed = reaction( () => console.log(counter.get()), // reaction body null, // reaction context (`this` for reaction body) () => setTimeout(() => delayed.run(), 1000) // reaction manager, should manage to run `.run()` method somehow ) delayed.run() // prints '3' counter.set(4) // prints '4' after 1 second","title":"Advanced reaction usage"},{"location":"introduction/#limitations","text":"Please avoid changing reaction's dependencies inside reaction body - this will cause reaction running in an infinite loop: const forever = reaction(() => counter.set(counter.get() + 1)) forever.run() // never ends","title":"Limitations"},{"location":"introduction/#reaction-utilities","text":"There are two utility functions that can help is some cases: when() accepts a condition function and body, so body gets executed in untracked transaction each time condition is true: const cond = observable(false); const r = when( () => cond.get(), () => { console.log(\"Condition is true\") } ); cond.set(true); // prints \"Condition is true\" cond.set(false); // doesn't print once() works the same as when() except the fact it runs only once when condition is set to true : const cond = observable(false); const r = once( () => cond.get(), () => { console.log(\"Condition is true\") } ); cond.set(true); // prints \"Condition is true\" cond.set(false); // doesn't print cond.set(true); // doesn't print too In all cases, when() and once() will run body if condition is initially set to true . Returned object is Reaction instance, so it could be destroyed or run again as usual reaction.","title":"Reaction utilities"},{"location":"introduction/#observable-utilities","text":"Using makeObservable helper it's easy to convert observable properties on some object into convenient getters and setters: const counter = makeObservable({ count: observable(0) }) counter.count // return 0 counter.count = 5 // sets observable to 5 Or the same with classes: class Counter { count = observable(0) constructor() { makeObservable(this) } } const counter = new Counter() Only object's own properties are converted . (You may also have noticed that code from Examples section uses observable.prop instead of observable for defining fields - in fact, it's exactly the same function, the only difference is its Typescript definition : type of observable.prop(T) is T , while type of observable(T) is Observable<T> ) There are also few helper functions designed to work with makeObservable : fromGetter and notify .","title":"Observable utilities"},{"location":"introduction/#extra-value-checked-observables-and-computeds","text":"By default, observables and computeds never touch the values they store, so they can't know if the assigned or computed value has changed. It's convinient for the most cases, but sometimes might lead to unnecessarily reactions or expensive computations you might want to eliminate. Observables and computeds receive an second options parameter, which can contain checkValue function, which receives previous and new values and returns a boolean equality result. If the result is true , no further recomputations of dependant computeds or reactions is done. Here's an example: // simple comparison function const checkValue = (prev, next) => prev === next; // pass the checkValue function to observable const counter = observable(1, { checkValue }); // pass the checkValue function to computed const absolute = computed( () => { console.log('computing absolute'); return Math.abs(counter.get()); }, { checkValue }, ); // regular computed without value check const doubleAbsolute = computed(() => { console.log('computing double') return absolute.get() * 2; }); const printer = reaction(() => { console.log('result is', doubleAbsolute.get()); }); // first run, prints 'computing absolute' and 'computing double' printer.run(); // checkValue is called for observable, no computeds are recalculated, reaction doesn't run counter.set(1); // prints 'computing absolute' and calls checkValue for computed, // doubleAbsolute computed is not recalculated and reaction doesn't run counter.set(-1); While the feature seems like a \"silver bullet\" for reducing amount of computation in your application, it comes with a price. Because dipole is guaratied to be glitch-free and consistent at every moment of time, there is some quite complicated logic behind the checkValue feature. Internally, dipole does a \"virtual\" run of every reaction potentially touched by the value-checked computeds change (called internally a \"state actualization\"), which implements some kind of topological sort of to-be-recomputed values, so the process might be not as lightweight as you could imagine. Given the fact, it's better to place value-checked computeds as close to reactions or consumers as possible, or at least benchmark cases with and without checkValue option.","title":"Extra: value-checked observables and computeds"}]}