<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="img/favicon.ico">

    
    <title>Home - dipole</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="css/base.min.css" rel="stylesheet">
    <link href="css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css">
        
    

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body class="homepage" >

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href=".">dipole</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li class="active">
                        <a href=".">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="api/">API reference</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="prev" >
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="api/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#dipole-tiny-reactive-state-management-that-just-works">dipole - tiny reactive state management that just works</a></li>
        <li class="first-level "><a href="#installation">Installation</a></li>
        <li class="first-level "><a href="#usage-with-react-bindings">Usage with React bindings</a></li>
            <li class="second-level"><a href="#example-0-counter-basics-of-observables-and-actions">Example 0: Counter. Basics of observables and actions</a></li>
                
            <li class="second-level"><a href="#example-1-counter-list-model-composition-and-computed-data">Example 1: Counter list. Model composition and computed data</a></li>
                
            <li class="second-level"><a href="#example-2-todomvc-the-classics-of">Example 2: TodoMVC. The classics of.</a></li>
                
        <li class="first-level "><a href="#introduction-into-core-features">Introduction into core features</a></li>
            <li class="second-level"><a href="#observable">Observable</a></li>
                
            <li class="second-level"><a href="#computed">Computed</a></li>
                
            <li class="second-level"><a href="#reaction-and-transaction">Reaction and transaction</a></li>
                
                <li class="third-level"><a href="#transaction">Transaction</a></li>
                <li class="third-level"><a href="#action-and-untracked-transaction">Action and untracked transaction</a></li>
                <li class="third-level"><a href="#nested-reactions">Nested reactions</a></li>
                <li class="third-level"><a href="#advanced-reaction-usage">Advanced reaction usage</a></li>
                <li class="third-level"><a href="#limitations">Limitations</a></li>
                <li class="third-level"><a href="#reaction-utilities">Reaction utilities</a></li>
            <li class="second-level"><a href="#observable-utilities">Observable utilities</a></li>
                
        <li class="first-level "><a href="#author">Author</a></li>
        <li class="first-level "><a href="#license">License</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="dipole-tiny-reactive-state-management-that-just-works">dipole - tiny reactive state management that just works</h1>
<p><a href="https://www.npmjs.com/package/dipole"><img alt="NPM version" src="https://img.shields.io/npm/v/dipole" /></a>
<a href="https://www.npmjs.com/package/dipole"><img alt="Minzipped size" src="https://img.shields.io/bundlephobia/minzip/dipole?color=green" /></a>
<a href="https://codecov.io/gh/zheksoon/dipole"><img alt="codecov" src="https://codecov.io/gh/zheksoon/dipole/branch/master/graph/badge.svg?token=WMVIB287XM" /></a></p>
<p><strong>dipole</strong> is tiny (just about 2K min gz) reactive state management library that could be used standalone or with React/Preact. It's heavily inspired by <a href="https://github.com/mobxjs/mobx">MobX</a> and was initially thought as a pedagogical re-implementation of its core features, and had grown later to a complete library. At this moment dipole can be seen as MobX minus "magic".</p>
<p><strong>dipole features</strong>:</p>
<ul>
<li>Clean and minimalistic object-oriented implementation of observable/functional reactive paradigm in about 300 lines of code</li>
<li>Opaque data structures - you can easily examine dipole internals in debugger, no class fields is mangled</li>
<li>Performance optimizations - even with a huge amount of observable/computed values dipole runs as efficiently as possible</li>
<li>Good test suit - 100% test coverage for complex use cases</li>
</ul>
<h1 id="installation">Installation</h1>
<pre><code class="language-bash">npm install --save dipole
</code></pre>
<h1 id="usage-with-react-bindings">Usage with React bindings</h1>
<h2 id="example-0-counter-basics-of-observables-and-actions">Example 0: Counter. Basics of observables and actions</h2>
<p><a href="https://codesandbox.io/s/dipole-react-example-counter-o4w64">Open in Codesandbox</a></p>
<pre><code class="language-jsx">import { action, observable, makeObservable } from &quot;dipole&quot;;
import { observer } from &quot;dipole-react&quot;;

let counterId = 0;

class CounterModel {
  // not observable field
  id = counterId++;
  // observable field
  count = observable.prop(0);

  constructor() {
    // creates getters and setters for observable fields for transparency
    makeObservable(this);
  }

  // actions are atomic changes on observables, see introduction below
  inc = action(() =&gt; (this.count += 1));
  dec = action(() =&gt; (this.count -= 1));
  reset = action(() =&gt; (this.count = 0));
}

// React component wrapped into `observer` re-renders on observable changes
const Counter = observer(({ model, onRemove }) =&gt; {
  return (
    &lt;div&gt;
      Counter is: {model.count}
      &lt;button onClick={model.inc}&gt;+&lt;/button&gt;
      &lt;button onClick={model.dec}&gt;-&lt;/button&gt;
      &lt;button onClick={model.reset}&gt;Reset&lt;/button&gt;
      {onRemove &amp;&amp; &lt;button onClick={() =&gt; onRemove(model.id)}&gt;Remove&lt;/button&gt;}
    &lt;/div&gt;
  );
});

const counterModel = new CounterModel();

ReactDOM.render(&lt;Counter model={counterModel} /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h2 id="example-1-counter-list-model-composition-and-computed-data">Example 1: Counter list. Model composition and computed data</h2>
<p>Using the counter example above, let's compose multiple Counter models into a more complex app.</p>
<p><a href="https://codesandbox.io/s/dipole-react-example-counter-list-u1fvc?file=/src/index.js">Open in Codesandbox</a></p>
<pre><code class="language-jsx">import { computed } from &quot;dipole&quot;;

class CounterListModel {
  counters = observable.prop([]);

  // computeds are fields with data derived from other computeds/observables
  countersTotal = computed.prop(() =&gt; {
    return this.counters.length;
  });

  countersSum = computed.prop(() =&gt; {
    return this.counters.reduce((acc, counter) =&gt; acc + counter.count, 0);
  });

  constructor() {
    makeObservable(this);
  }

  addCounter = action(() =&gt; {
    const counter = new CounterModel();
    this.counters.push(counter);
    // as observables are dumb containers for data,
    // we need to let them know about changes in underlying data structures
    this.counters = this.counters; // or notify(() =&gt; this.counters)
  });

  removeCounter = action((id) =&gt; {
    // no need for notify() because we are doing an assignment here
    this.counters = this.counters.filter((counter) =&gt; counter.id !== id);
  });

  // action can aggregate multiple other actions and still be atomic
  resetAll = action(() =&gt; {
    this.counters.forEach((counter) =&gt; counter.reset());
  });
}

const CounterList = observer(({ model }) =&gt; {
  return (
    &lt;div&gt;
      &lt;p&gt;Counters total: {model.countersTotal}&lt;/p&gt;
      &lt;p&gt;Counters sum: {model.countersSum}&lt;/p&gt;
      {model.counters.map((counter) =&gt; (
        &lt;Counter
          key={counter.id}
          model={counter}
          onRemove={model.removeCounter}
        /&gt;
      ))}
      &lt;button onClick={model.addCounter}&gt;Add counter&lt;/button&gt;
      &lt;button onClick={model.resetAll}&gt;Reset all&lt;/button&gt;
    &lt;/div&gt;
  );
});

const counterListModel = new CounterListModel();

ReactDOM.render(&lt;CounterList model={counterListModel} /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h2 id="example-2-todomvc-the-classics-of">Example 2: TodoMVC. The classics of.</h2>
<p><a href="https://github.com/zheksoon/dipole-react-todo-mvc">Repository</a></p>
<p><a href="https://codesandbox.io/s/dipole-react-example-todo-mvc-typescript-7rxzw?file=/src/App.tsx">Open in Codesandbox</a></p>
<h1 id="introduction-into-core-features">Introduction into core features</h1>
<p>Dipole core consists three main classes: <code>Observable</code>, <code>Computed</code> and <code>Reaction</code>. All the classes can be constructed via non-capitalized factory functions <code>observable</code>, <code>computed</code> and <code>reaction</code> correspondingly without <code>new</code> keyword.</p>
<h2 id="observable">Observable</h2>
<p>Observables are containers that contain some value and allow some other dependent objects to get notified when the value changes.</p>
<pre><code class="language-js">import { observable } from 'dipole'

const counter = observable(0)
counter.get()   // returns 0
counter.set(1)  // sets observable value to 1
</code></pre>
<p>For sure, it might be not convinient to call <code>.get()</code> or <code>.set()</code> on every observable access, so <a href="#observable-utilities">there are some helpers</a> to make the the process easy and transparent.</p>
<h2 id="computed">Computed</h2>
<p>Computed values are values that are derived from other observables and computeds with some pure function. The function should not contain any side-effects other than returning a value and depend only on observable/computed values. The result of computed is cached until any of its dependencies are changed.</p>
<pre><code class="language-js">import { observable, computed } from 'dipole'

const counter = observable(1)

const double = computed(() =&gt; {
    console.log('Computing double value...')
    return counter.get() * 2
})
double.get()    // prints 'Computing double value...' and returns 2
double.get()    // doesn't print and returns 2 - the result is cached!

counter.set(2)  // update computed dependency
double.get()    // prints 'Computing double value...' and returns 4

// another way to invalidate an observable is to call `.notify()`
// this is useful when observable contains a complex object like Array or Map
counter.notify()
double.get()    // prints 'Computing double value...' and returns 4 again
</code></pre>
<p>Of course computed values can contain any kind of conditions/loops that dynamically reference to different observables, this will be correctly handled by dipole:</p>
<pre><code class="language-js">const cond = observable(true)
const a = observable('a')
const b = observable('b')

const result = computed(() =&gt; {
    console.log('Computing result...')
    return cond.get() ? a.get() : b.get()
})
result.get()    // prints 'Computing result' and returns 'a'
                // now `result` depends on `cond` and `a` values
cond.set(false)
result.get()    // prints 'Computing result' and returns 'b'
                // now `result` depends on `cond` and `b` values

a.set('aa')     // `result` doesn't depend on `a`, nothing will happen
result.get()    // nothing changed for `result`, just returns 'b' again

b.set('bb')     // change `result` dependency
result.get()    // prints 'Computing result' and returns 'bb'
</code></pre>
<p>There are some intuitive limitations for computed values:</p>
<p>1) They can't recursively refer to itself:</p>
<pre><code class="language-js">const recur = computed(() =&gt; recur.get() + 1)
recur.get() // throws 'Trying to get computed value while in computing state'
</code></pre>
<p>2) They must not change any observable or trigger any side-effects:</p>
<pre><code class="language-js">const badBoy = computed(() =&gt; counter.set(0))
badBoy.get()    // throws `Can't change observable value inside of computed`
</code></pre>
<h2 id="reaction-and-transaction">Reaction and transaction</h2>
<p>Reactions are automatic actions that are triggered on dependent observable/computed changes</p>
<pre><code class="language-js">const a = observable(1)
const b = observable(2)

const sum = computed(() =&gt; a.get() + b.get())

const r = reaction(() =&gt; {
    console.log(`Sum of ${a.get()} and ${b.get()} is ${sum.get()}`)
})
r.run()   // first run should be triggered manually
          // prints 'Sum of 1 and 2 is 3'

a.set(3)  // prints 'Sum of 3 and 2 is 5'
b.set(4)  // prints 'Sum of 3 and 4 is 7'
</code></pre>
<h3 id="transaction">Transaction</h3>
<p>Last lines show that reaction reacts to <strong>each</strong> change in its dependencies, synchronously. But what if we want to batch changes and run reaction only once after both <code>a</code> and <code>b</code> changes?
Here's the answer: <strong>transaction</strong>:</p>
<pre><code class="language-js">// `tx` stands for `transaction`
import { tx } from 'dipole'

tx(() =&gt; {
    a.set(2)  // doesn't react
    b.set(3)  // doesn't react too
})            // prints 'Sum 2 and 3 is 5' right after the transaction end
</code></pre>
<h3 id="action-and-untracked-transaction">Action and untracked transaction</h3>
<p><strong>Actions</strong> are functions wrapped in transaction. But there is also one significant difference with plain transactions: actions are <strong>untracked</strong>. This means that any access to any observable or computed fields performed in action won't be tracked by calling function/reaction. This makes actions building pieces of your application - they could be safely called from any place with predictable consequences. </p>
<p>Actions do really play well with <a href="#observable-utilities">observable utilities</a>, making writing complex mutations simple.</p>
<pre><code class="language-js">import { observable, action, makeObservable } from 'dipole'

class SumModel {
  constructor(a, b) {
    this.a = observable.prop(a)
    this.b = observable.prop(b)
    makeObservable(this)
  }

  addBoth = action((amount) =&gt; {
    this.a += amount
    this.b += amount
  })
}

const model = new SumModel(1, 2);

model.addBoth(3);
</code></pre>
<p>Sometimes inplace untracked transactions are usefull too, so there is <code>utx</code> function for this (<code>utx</code> stands for Untracked TX):</p>
<pre><code class="language-js">class UserModel {
  isLoading = observable.prop(false);
  user = observanle.prop(null);
  error = observable.prop(null);

  constructor() {
    makeObservable(this);
  }

  // async functions can't be wrapped in `action`, so using `utx` inplace for observable changes
  async fetchUser() {
    utx(() =&gt; this.isLoading = true);
    try {
      const response = await userService.getData();
      utx(() =&gt; {
        this.user = response.user;
        this.isLoading = false;
      });
    } catch (err) {
      utx(() =&gt; {
        this.error = err;
        this.isLoading = false;
      })
    }
  }
}
</code></pre>
<p><code>utx</code> function also returns the result of its body execution, so it could be used for peeking at some observables/computed values without getting them tracked by underlying reaction/computed:</p>
<pre><code class="language-js">const person = observable('Alice')

const government = reaction(() =&gt; {
    const who = utx(() =&gt; person.get());
    console.log(`${who} is caught!`);
})
government.run();       // Alice is caught! but...

person.set('Anonymous') // you get it! :)
</code></pre>
<p>Reactions can be destroyed, so they will not run after that:</p>
<pre><code class="language-js">r.destroy()
a.set(4)    // doesn't react to the change anymore
</code></pre>
<h3 id="nested-reactions">Nested reactions</h3>
<p>Since dipole version 2.2.0 reactions that get created while another reaction is executed become <strong>children</strong> of the parent reaction. Child reactions get automatically destroyed when parent is destroyed or run. </p>
<p>Why is this needed? </p>
<p>This behaviour enables building hierarchical constructs, where one reaction (say, router) creates another reaction (say, view or page), and changes that trigger router reaction automatically destroy view reaction, so all related resources could be freed.</p>
<p>For more context, see <a href="https://github.com/zheksoon/dipole/issues/5">this issue</a>.</p>
<p>In case you want intentially create a reaction without parent, just do it inside untracked transaction:</p>
<pre><code class="language-js">const free = utx(() =&gt; reaction(() =&gt; { ...reaction body... }));
</code></pre>
<h3 id="advanced-reaction-usage">Advanced reaction usage</h3>
<p>Advanced reaction usage with reaction context and manager argument:</p>
<pre><code class="language-js">const delayed = reaction(
    () =&gt; console.log(counter.get()),   // reaction body
    null,                   // reaction context (`this` for reaction body)
    () =&gt; setTimeout(() =&gt; delayed.run(), 1000)  // reaction manager, should manage to run `.run()` method somehow
)
delayed.run()   // prints '3'
counter.set(4)  // prints '4' after 1 second
</code></pre>
<h3 id="limitations">Limitations</h3>
<p>Please avoid changing reaction's dependencies inside reaction body - this will cause reaction running in an infinite loop:</p>
<pre><code class="language-js">const forever = reaction(() =&gt; counter.set(counter.get() + 1))
forever.run()   // never ends
</code></pre>
<h3 id="reaction-utilities">Reaction utilities</h3>
<p>There are two utility functions that can help is some cases:</p>
<ul>
<li><code>when()</code> accepts a condition function and body, so body gets executed in untracked transaction each time condition is true:</li>
</ul>
<pre><code class="language-js">const cond = observable(false);

const r = when(
    () =&gt; cond.get(),
    () =&gt; { console.log(&quot;Condition is true&quot;) }
);

cond.set(true);  // prints &quot;Condition is true&quot;
cond.set(false); // doesn't print
</code></pre>
<ul>
<li><code>once()</code> works the same as <code>when()</code> except the fact it runs only once when condition is set to <code>true</code>:</li>
</ul>
<pre><code class="language-js">const cond = observable(false);

const r = once(
    () =&gt; cond.get(),
    () =&gt; { console.log(&quot;Condition is true&quot;) }
);

cond.set(true);  // prints &quot;Condition is true&quot;
cond.set(false); // doesn't print
cond.set(true);  // doesn't print too
</code></pre>
<p>In all cases, <code>when()</code> and <code>once()</code> will run body if condition is initially set to <code>true</code>.</p>
<p>Returned object is <code>Reaction</code> instance, so it could be destroyed or run again as usual reaction.</p>
<h2 id="observable-utilities">Observable utilities</h2>
<p>Using <code>makeObservable</code> helper it's easy to convert observable properties on some object into convenient getters and setters:</p>
<pre><code class="language-js">const counter = makeObservable({ count: observable(0) })

counter.count     // return 0
counter.count = 5 // sets observable to 5
</code></pre>
<p>Or the same with classes:</p>
<pre><code class="language-js">class Counter {
  count = observable(0)

  constructor() {
    makeObservable(this)
  }
}

const counter = new Counter()
</code></pre>
<p>Only object's own properties <a href="#make-observable">are converted</a>.</p>
<p>(You may also have noticed that code from <a href="#examples">Examples</a> section uses <code>observable.prop</code> instead of <code>observable</code> for defining fields - in fact, it's exactly the same function, the only difference is <a href="https://github.com/zheksoon/dipole/blob/master/src/index.d.ts#L30">its Typescript definition</a>: type of <code>observable.prop(T)</code> is <code>T</code>, while type of <code>observable(T)</code> is <code>Observable&lt;T&gt;</code>)</p>
<p>There are also few helper functions designed to work with <code>makeObservable</code>: <a href="#fromgetter">fromGetter</a> and <a href="#notify">notify</a>.</p>
<h1 id="author">Author</h1>
<p>Eugene Daragan</p>
<h1 id="license">License</h1>
<p>MIT</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = "."</script>
    
    <script src="js/base.js"></script>
    <script src="search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>

<!--
MkDocs version : 1.2.3
Build Date UTC : 2021-11-05 12:54:18.867819+00:00
-->
